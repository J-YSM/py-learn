# -*- coding: utf-8 -*-
"""
learn-binarytree
"""

import collections
import weakref
dir(collections)










# -*- coding: utf-8 -*-
"""
learn-descriptors
"""

#==============================================================================
# methods as dynamic attributes 
#==============================================================================

from random import randint

class list_wrapper(object):

    def __init__(self, iterator=None):
        if iterator:
            self.length = len(iterator)
            self._x = list(iterator)
        else:
            self.length = 0
            self._x = list()

    @classmethod
    def random(cls, n):
        return cls([randint(-1000,1000) for _ in range(n)])

    @classmethod
    def random2(cls, n):
        obj = cls.__new__(cls) # wont call __init__
        obj.length = n
        obj._x = [randint(-1000,1000) for _ in range(n)]
        return obj
    
    @staticmethod
    def var():
        print("no instance")
    
    @property #getter
    def x(self):
        return self._x
    @x.setter
    def x(self, element):
        self.length += 1 # eager ompute, bind to attributes
        self._x.append(element)
    @x.deleter
    def x(self):
        self.length -= 1
        self._x.pop(-1)

list_wrapper()
a=list_wrapper.random(10)
a.x
a.x = 9999
a.length
del a.x

list_wrapper.random2(10).x

#==============================================================================
# create descriptors - __get__ (non data don't have) and __set__ and __del__
#==============================================================================

class UnitValue_1:
    """Measure and Unit combined."""
    def __init__( self, unit ):
        self.value= None # mutable
        self.unit= unit # immutable
        self.default_format= "5.2f"
    def __set__( self, instance, value ): #only so NON DATA 
        self.value= value
    def __str__( self ):
        return "{value:{spec}} {unit}".format( spec=self.default_format, **self.__dict__)
    def __format__( self, spec="5.2f" ):
        #print( "formatting", spec )
        if spec == "": 
            spec= self.default_format
        return "{value:{spec}} {unit}".format( spec=spec,
                **self.__dict__)

class RTD_1:
    """ descriptors as cls attributes """
    rate= UnitValue_1( "kt" )
    time= UnitValue_1( "hr" )
    distance= UnitValue_1( "nm" )

    def __init__( self, rate=None, time=None, distance=None ):
        if rate is None:
            self.time = time
            self.distance = distance
            self.rate = distance / time
        if time is None:
            self.rate = rate
            self.distance = distance
            self.time = distance / rate
        if distance is None:
            self.rate = rate
            self.time = time
            self.distance = rate * time
    def __str__( self ):
        # access cls attrs
        return "rate: {0.rate} time: {0.time} distance: {0.distance}".format(self)

m1 = RTD_1( rate=5.8, distance=12 )
str(m1)

#==============================================================================
# data descriptor
#==============================================================================

class Unit:
    """ superclass of data descriptor """
    conversion= 1.0
    def __get__( self, instance, owner ): #auto conversion
        return instance.kph * self.conversion
    def __set__( self, instance, value ):
        instance.kph = value / self.conversion

class KPH( Unit ):
    def __get__( self, instance, owner ): #auto conversion
        return instance._kph # return _kph instead of kph, avoid INF recursion
    def __set__( self, instance, value ):
        instance._kph = value
        
class Knots( Unit ):
    conversion= 0.5399568

class MPH( Unit ):
    conversion= 0.62137119

class Measurement:
    """ Owner owning data descriptors objs
        Share the same superclass Unit """
    kph= KPH()
    knots= Knots()
    mph= MPH()

    def __init__( self, kph=None, mph=None, knots=None ):
        if kph: self.kph= kph
        elif mph: self.mph= mph
        elif knots: self.knots= knots
        else:
            raise TypeError
    def __str__( self ):
        return "rate: {0.kph} kph = {0.mph} mph = {0.knots} knots".format(self)

m2 = Measurement(knots=5.9)
str(m2)



# -*- coding: utf-8 -*-
"""
learn-mutability
"""

class ImmutableObj(object):
    __slots__ = ('x','y') # turn off __dict__ 
    def __init__(self,x,y):
        super().__setattr__('x',x) #use object's 
        super().__setattr__('y',y)
    def __str__(self):
        return "str: x={0.x} y={0.y}".format(self)
    def __repr__(self):
        return "repr: x={0.x} y={0.y}".format(self)
    def __setattr__(self,name,value):
        print("name={name} value={value}".format(name=name,value=value))
        print("No setting allowed after init")
        super.__setattr__(name,value) # self[name] = value
    def __getattr__( self, name ):
        print("name={name}".format(name=name))
        return self.get(name, None) # None force to look for solution
        
a=ImmutableObj(1,2)
a
print(a)        
a.x=1
object.__setattr__(a,'x',100) # multi inheritance MRO bypass
print(a)

#==============================================================================
# extend immutable obj
#==============================================================================

class NewTuple(tuple):
    def __new__(cls,*args):
        return super().__new__(cls,(args))
    def __getattr__(self,name):
        print("getattr")
        try:
            _fixedDict = {"x":1,"y":2}
            return self[_fixedDict[name]]
        except:
            print("{name} not found".format(name=name))
            raise AttributeError
    def __setattr__(self,index,value):
        print("cannot set attr. overriden!")
        
a=NewTuple(1,2,3)
a.a
a.x
a.x=1


a=lambda x: x
a(1)

#==============================================================================
# 
#==============================================================================


class NewList(list):
    def __init__(self,x,y):
        self.x = x
        self.y = y        
    def __setattr__(self,name,value):
        if name in self.__dict__:
            raise AttributeError( "Cannot set {name}".
                                 format(name=name) )
        else:
            super().__setattr__(name,value)
    def __getattribute__( self, name ):
        if name.startswith('_'): 
            raise AttributeError
        return object.__getattribute__( self, name )

a=NewList(1,2)
a.x=1

class test:
    a=1
    def __getattribute__( self, name ):
        if name.startswith('_'): 
            raise AttributeError
        return object.__getattribute__( self, name )

dir(test())

# -*- coding: utf-8 -*-
"""
learn-list
"""


import math

class StatsList(list):
    """ lazy eval """
    def __init__(self,*args,**kwargs):
        super().__init__(*args,**kwargs)
    @property
    def mean(self):
        return sum(self) / len(self)
    @property
    def stdev(self):
        n = len(self)
        return math.sqrt( n*sum(x**2 for x in self)-sum(self)**2)/n

x=StatsList([1,2,3])
x.mean
x.stdev

#==============================================================================
# 
#==============================================================================

class StatsList2(list):
    """Eager Stats."""
    def __init__( self, *args, **kw ):
        self.sum0 = 0 # len(self)
        self.sum1 = 0 # sum(self)
        self.sum2 = 0 # sum(x**2 for x in self)
        super().__init__( *args, **kw )
        for x in self:
            self._new(x)

    def _new( self, value ):
        self.sum0 += 1
        self.sum1 += value
        self.sum2 += value*value

    def _rmv( self, value ):
        self.sum0 -= 1
        self.sum1 -= value
        self.sum2 -= value*value

    def insert( self, index, value ):
        super().insert( index, value )
        self._new(value)

    def pop( self, index=0 ):
        value= super().pop( index )
        self._rmv(value)
        return value

    @property
    def mean(self):
        return self.sum1/self.sum0
    @property
    def stdev(self):
        return math.sqrt( self.sum0*self.sum2-self.sum1*self.sum1
                         )/self.sum0

    def __setitem__( self, index, value ):
        if isinstance(index, slice):
            start, stop, step = index.indices(len(self))
        olds = [ self[i] for i in range(start,stop,step) ]
        super().__setitem__( index, value )
        for x in olds:
            self._rmv(x)
        for x in value:
            self._new(x)
        else: # int 
            old= self[index]
            super().__setitem__( index, value )
            self._rmv(old)
            self._new(value)

    def __delitem__( self, index ):
    # Index may be a single integer, or a slice
        if isinstance(index, slice):
            start, stop, step = index.indices(len(self))
            olds = [ self[i] for i in range(start,stop,step) ]
            super().__delitem__( index )
            for x in olds:
                self._rmv(x)
        else:
            old = self[index]
            super().__delitem__( index )
            self._rmv(old)


x=StatsList2([1,2,3])
x.stdev

#==============================================================================
# 
#==============================================================================

class Explore(list):
    def __getitem__( self, index ):
        print(type(index))
        print(dir(index))
        print( index, index.indices(len(self)) )
        return super().__getitem__( index )

x=Explore("1bcde")
x[0:3:2]
x[:]
x[:-1]

slice

#==============================================================================
# 
#==============================================================================













# -*- coding: utf-8 -*-
"""
learn-callables
"""

import timeit

def fib1(n):
    if n<=0: return 0
    elif n==1: return 1
    else:
        return fib1(n-1) + fib1(n-2)
    
timeit.timeit("fib1(10)",
              """ 
def fib1(n):
    if n<=0: return 0
    elif n==1: return 1
    else:
        return fib1(n-1) + fib1(n-2)
              """,
              number=1000)

%timeit -r 10 fib1(10)

#==============================================================================
# callable object, stateful function
#==============================================================================

import collections

class fibb(collections.abc.Callable):
    """ function-like object """
    def __init__(self):
        self.cache= {"0":0,"1":1}
        
    def __call__(self, n):
        if str(n) not in self.cache:
            if n <= 0:
                return self.cache["0"]
            elif n == 1:
                return self.cache["1"]
            else:
                self.cache[str(n)] = self.__call__(n-2) + self.__call__(n-1)
        
        return self.cache[str(n)]

fib2 = fibb()

fib2(10)
fib2.cache

%timeit -r 10 fib2(10)

#==============================================================================
# memonisation deocrator
#==============================================================================

class Memoize(collections.abc.Callable):
    def __init__(self, func):
        self.func = func
        self.cache = {}
    def __call__(self, *args):
        if args in self.cache:
            return self.cache[args]
        ret = self.func(*args)
        self.cache[args] = ret
        return ret

@Memoize
def fib3(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib3(n-2) + fib3(n-1)

fib3(10)
fib3.cache

%timeit -r 10 fib3(10)


#==============================================================================
# 
#==============================================================================

def fib(a, cache={0:1,1:1}):
    if a in cache: return cache[a]                                                                                 
    res = fib(a-1, cache) + fib(a-2, cache)                                                                        
    cache[a] = res                                                                                                 
    return res  

#==============================================================================
# 
#==============================================================================

from functools import lru_cache
lru_cache?

@lru_cache(maxsize=1000)
def fib1(n):
    if n<=0: return 0
    elif n==1: return 1
    else:
        return fib1(n-1) + fib1(n-2)
    
%timeit -r 10 fib1(10)










    
