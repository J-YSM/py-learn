

from logger.exception_decorator import *
#import different types of logger using logging module
from logger.exception_logger import *


instructions="""
#########
# Setup
#########
Set LOGTO "constant" to path of exception catching output e.g. C:/folder/log.txt

############
# Functions
############
1. catch_exception - decorate f with try catch
2. class_decorator - to use 1.catch_exception for all methods in class
3. logging_metaclass - to use 1.catch_exception for all methods in class

For unittest Demo, please refer to logger.test_logger

"""

print(instructions)



from functools import wraps


def catch_exception(logger):
    """
    A decorator that wraps the passed in function and logs 
    exceptions should one occur
    @param logger: The logging object

    ##############
    Example
    ###############
    class test():
        def __init__(self):
            pass
        @log.catch_exception(logger)
        def method(self,a=1):
            an_undeclared_var_to_cause_error
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except:
                # log the exception
                err = "There was an exception in  "
                err += func.__name__
                logger.exception(err)
 
            # re-raise the exception to interpreter
            raise
        return wrapper
    return decorator

def class_decorator(decorator):
    """
    Decorate class so that all its methods is decorated with the decorator.
    There's propably a better way to do this since will also decorate nested classes.
    Special methods like __init__ are not excluded
    ##############
    Example
    ###############
    @class_decorator(log.catch_exception(logger))
    class test():    
        def __init__(self):
            pass    
        def method(self):
            an_undeclared_var_to_cause_error
    """
    @wraps(decorator)
    def decorate(cls):
        for attr in cls.__dict__: 
            print("methodname: " + attr)
            if callable(getattr(cls, attr)) \
            and attr not in ['__init__','__module__', '__qualname__']:
                print(cls, attr)
                # cls.attr = decorator(getattr(cls, attr))
                setattr(cls, attr, decorator(getattr(cls, attr)))
        return cls
    return decorate

class logging_metaclass(type):
    """
    Decorate class so that all its methods is decorated with the decorator.
    There's propably a better way to do this since will also decorate nested classes.
    Special methods like __init__ are not excluded
    This is a new type so __module__ and __qualname__ not excluded.
    
    ##############
    Example
    ###############
    class test(metaclass = logging_metaclass, logger=log.catch_exception(logger)):
        # logger as kwargs ---> passed into Metaclass **kwargs namespace
        def __init__(self):
            pass    
        def method(self):
            an_undeclared_var_to_cause_error
    """
    def __new__(self, class_name, bases, local_namespace, **kwargs):
        #kwargs dict is passed from class kwargs
        for methodname in local_namespace:
            print("methodname: " + methodname)
            if callable(local_namespace[methodname]) \
            and methodname not in ['__init__','__module__', '__qualname__']:
                print("method " + str(local_namespace[methodname]) + " is callable")
                local_namespace[methodname] = \
                kwargs["logger"](local_namespace[methodname])
        return type.__new__(self, class_name, bases, local_namespace)




import logging
import os as __os
 
def create_logger(LOGTO=__os.getcwd()+"\\logger.txt" , level = logging.INFO):
    """
    Creates a logging object and returns it
    how to use?
    catch_exception( create_logger(destination_path, level = logging.INFO) )
    """
    print("Saving log to " + str(LOGTO))
    logger = logging.getLogger("example_logger")
    logger.setLevel(level)
 
    # create the logging file handler
    fh = logging.FileHandler(LOGTO)
 
    fmt = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    formatter = logging.Formatter(fmt)
    fh.setFormatter(formatter)
 
    # add handler to logger object
    logger.addHandler(fh)
    return logger

#logger = create_logger()

#==============================================================================
# not for error catching, for logging all steps
#==============================================================================

import re, sys, types 
#@@@ should use the standard python logging system?
log = sys.stdout

# Globally incremented across function calls, so tracks stack depth
indent = 0
indStr = '  '


__doc__ = """
Have all your function & method calls automatically logged, in indented outline
form - unlike the stack snapshots in an interactive debugger, it tracks call
structure & stack depths across time!
It hooks into all function calls that you specify, and logs each time they're
called.  I find it especially useful when I don't know what's getting called
when, or need to continuously test for state changes.  (by hacking this file)
Originally inspired from the python cookbook: 
http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/198078
Currently you can
 - tag functions or individual methods to be autologged
 - tag an entire class's methods to be autologged
 - tag an entire module's classes and functions to be autologged
TODO:
 - allow tagging of ALL modules in the program on startup?
CAVEATS:
 - certain classes barf when you logclass() them -- most notably,
   SWIG-generated wrappers, and perhaps others.
USAGE: see examples on the bottom of this file.
Viewing tips
============
If your terminal can't keep up, try xterm or putty, they seem to be highest
performance.  xterm is available for all platforms through X11...
Also try:    (RunChandler > log &); tail -f log
Also, you can  "less -R log"  afterward and get the colors correct.
If you have long lines, less -RS kills wrapping, enhancing readability. Also
can chop at formatAllArgs().
If you want long lines to be chopped realtime, try piping through less::
   RunChandler | less -RS
but then you have to hit 'space' lots to prevent chandler from freezing.
less's 'F' command is supposed to do this correctly but doesn't work for me.
"""


#@@@ should use the standard python logging system?
LOGTO = sys.stdout

# Globally incremented across function calls, so tracks stack depth
indent = 0
indStr = '  '


# ANSI escape codes for terminals.
#  X11 xterm: always works, all platforms
#  cygwin dosbox: run through |cat and then colors work
#  linux: works on console & gnome-terminal
#  mac: untested


BLACK     =        "\033[0;30m"
BLUE      =        "\033[0;34m"
GREEN     =        "\033[0;32m"
CYAN      =       "\033[0;36m"
RED       =        "\033[0;31m"
PURPLE    =        "\033[0;35m"
BROWN     =        "\033[0;33m"
GRAY      =        "\033[0;37m"
BOLDGRAY  =       "\033[1;30m"
BOLDBLUE     =   "\033[1;34m"
BOLDGREEN    =   "\033[1;32m"
BOLDCYAN     =   "\033[1;36m"
BOLDRED      =   "\033[1;31m"
BOLDPURPLE   =   "\033[1;35m"
BOLDYELLOW   =         "\033[1;33m"
WHITE     =        "\033[1;37m"

NORMAL = "\033[0m"



def indentlog(message):
    global LOGTO, indStr, indent
    print("%s%s" %(indStr*indent, message), log)
    log.flush()

def shortstr(obj):
    """
    Where to put gritty heuristics to make an object appear in most useful
    form. defaults to __str__.
    """
    if "wx." in str(obj.__class__)  or  obj.__class__.__name__.startswith("wx"):
        shortclassname = obj.__class__.__name__
        ##shortclassname = str(obj.__class__).split('.')[-1]
        if hasattr(obj, "blockItem") and hasattr(obj.blockItem, "blockName"):
            moreInfo = "block:'%s'" %obj.blockItem.blockName
        else:
            moreInfo = "at %d" %id(obj)
        return "<%s %s>" % (shortclassname, moreInfo)
    else:
        return str(obj)

def formatAllArgs(args, kwds):
    """
    makes a nice string representation of all the arguments
    """
    allargs = []
    for item in args:
        allargs.append('%s' % shortstr(item))
    for key,item in kwds.items():
        allargs.append('%s=%s' % (key,shortstr(item)))
    formattedArgs = ', '.join(allargs)
    if len(formattedArgs) > 150:
        return formattedArgs[:146] + " ..."
    return formattedArgs

def logmodule(module, logMatch=".*", logNotMatch="nomatchasfdasdf"):
    """ 
    WARNING: this seems to break if you import SWIG wrapper classes
    directly into the module namespace ... logclass() creates weirdness when
    used on them, for some reason.
    
    @param module: could be either an actual module object, or the string
                   you can import (which seems to be the same thing as its
                   __name__).  So you can say logmodule(__name__) at the end
                   of a module definition, to log all of it.
    """
    
    allow = lambda s: re.match(logMatch, s) and not re.match(logNotMatch, s)
    
    if isinstance(module, str):
        d = {}
        exec("import %s" % module  in d)
        import sys
        module = sys.modules[module]
        
    names = module.__dict__.keys()
    for name in names:
        if not allow(name): continue
        
        value = getattr(module, name)
        if isinstance(value, type):
            setattr(module, name, logclass(value))
            print("autolog.logmodule(): bound %s" %name, log)
        elif isinstance(value, types.FunctionType):
            setattr(module, name, logfunction(value))
            print("autolog.logmodule(): bound %s" %name, log)

def logfunction(theFunction, displayName=None):
    """a decorator."""
    if not displayName: displayName = theFunction.__name__

    def _wrapper(*args, **kwds):
        global indent
        argstr = formatAllArgs(args, kwds)
        
        # Log the entry into the function
        indentlog("%s%s%s  (%s) " % (BOLDRED,displayName,NORMAL, argstr))
        log.flush()
        
        indent += 1
        returnval = theFunction(*args,**kwds)
        indent -= 1
        
        # Log return
        ##indentlog("return: %s"% shortstr(returnval)
        return returnval
    return _wrapper

def logmethod(theMethod, displayName=None):
    """use this for class or instance methods, it formats with the object out front."""
    if not displayName: displayName = theMethod.__name__
    def _methodWrapper(self, *args, **kwds):
        "Use this one for instance or class methods"
        global indent

        argstr = formatAllArgs(args, kwds)        
        selfstr = shortstr(self)
            
        #print >> log,"%s%s.  %s  (%s) " % (indStr*indent,selfstr,methodname,argstr)
        indentlog("%s.%s%s%s  (%s) " % (selfstr,  BOLDRED,theMethod.__name__,NORMAL, argstr))
        log.flush()
        
        indent += 1
        
        if theMethod.__name__ == 'OnSize':
            indentlog("position, size = %s%s %s%s" %(BOLDBLUE, self.GetPosition(), self.GetSize(), NORMAL))

        returnval = theMethod(self, *args,**kwds)

        indent -= 1
        
        return returnval
    return _methodWrapper


def logclass(cls, methodsAsFunctions=False, 
             logMatch=".*", logNotMatch="asdfnomatch"):
    """ 
    A class "decorator". But python doesn't support decorator syntax for
    classes, so do it manually::
    
        class C(object):
           ...
        C = logclass(C)
    
    @param methodsAsFunctions: set to True if you always want methodname first
    in the display.  Probably breaks if you're using class/staticmethods?
    """

    allow = lambda s: re.match(logMatch, s) and not re.match(logNotMatch, s) and \
          s not in ('__str__','__repr__')
    
    namesToCheck = cls.__dict__.keys()
                    
    for name in namesToCheck:
        if not allow(name): continue
        # unbound methods show up as mere functions in the values of
        # cls.__dict__,so we have to go through getattr
        value = getattr(cls, name)
        
        if methodsAsFunctions and callable(value):
            setattr(cls, name, logfunction(value))            
        elif isinstance(value, types.MethodType):
            #a normal instance method
            if value.im_self == None:                 
                setattr(cls, name, logmethod(value))
            
            #class & static method are more complex.
            #a class method
            elif value.im_self == cls:                
                w = logmethod(value.im_func, 
                              displayName="%s.%s" %(cls.__name__, value.__name__))
                setattr(cls, name, classmethod(w))
            else: assert False

        #a static method
        elif isinstance(value, types.FunctionType):
            w = logfunction(value, 
                            displayName="%s.%s" %(cls.__name__, value.__name__))
            setattr(cls, name, staticmethod(w))
    return cls

class LogMetaClass(type):
    """
    Alternative to logclass(), you set this as a class's __metaclass__.
    
    It will not work if the metaclass has already been overridden (e.g.
    schema.Item or zope.interface (used in Twisted) 
    
    Also, it should fail for class/staticmethods, that hasnt been added here
    yet. 
    """
    
    def __new__(cls,classname,bases,classdict):
        logmatch = re.compile(classdict.get('logMatch','.*'))
        lognotmatch = re.compile(classdict.get('logNotMatch', 'nevermatchthisstringasdfasdf'))
        
        for attr,item in classdict.items():
            if callable(item) and logmatch.match(attr) and not lognotmatch.match(attr):
                classdict['_H_%s'%attr] = item    # rebind the method
                classdict[attr] = logmethod(item) # replace method by wrapper

        return type.__new__(cls,classname,bases,classdict)




import inspect
import logging
import traceback

def get_function_name():
    return traceback.extract_stack(None, 2)[0][2]

def get_function_parameters_and_values():
    frame = inspect.currentframe().f_back
    args, _, _, values = inspect.getargvalues(frame)
    return ([(i, values[i]) for i in args])

def my_func(a, b, c=None):
    logging.info('Running ' + get_function_name() + '(' + str(get_function_parameters_and_values()) +')')
    pass

logger = logging.getLogger()
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s [%(levelname)s] -> %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.INFO)

my_func(1, 3) # 2016-03-25 17:16:06,927 [INFO] -> Running my_func([('a', 1), ('b', 3), ('c', None)])


import logger as log
import unittest

#dir(unittest.TestCase)
#unittest.TestCase.assertRaises?

class TestLogger(unittest.TestCase):
    
    def test_raise_exception(self):

        logger=log.create_logger()    
        @log.catch_exception(logger)
        def zero_divide():
            1 / 0
        self.assertRaises(RuntimeError, zero_divide())

    def test_class_decorator(self):

        logger=log.create_logger()    
        @log.class_decorator(log.catch_exception(logger))
        class test():    
            def __init__(self):
                pass    
            def method(self):
                an_undeclared_var_to_cause_error

        self.assertRaises(RuntimeError, test().method())


    def test_logging_metaclass(self):
    
        logger=log.create_logger()    
        class test2(metaclass = log.logging_metaclass, logger=log.catch_exception(logger)):
            # logger as kwargs ---> passed into Metaclass **kwargs namespace
            def __init__(self):
                pass    
            def method(self):
                an_undeclared_var_to_cause_error 
        
        self.assertRaises(RuntimeError, test2().method())


if __name__ == '__main__':
    unittest.main()

