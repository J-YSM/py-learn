#==============================================================================
# init pyexcel
#==============================================================================

# expand namespace from package dir
from proj_pyexcel.core import editor

#==============================================================================
# core
#==============================================================================

import pandas as pd
import string

from functools import wraps, partial
import xlwings as xw
import win32com.client; win32c = win32com.client.constants
from openpyxl import load_workbook
        
#from string import Template
#import zipfile
#import os
#import numpy as np

from proj_pyexcel.decorators import *
from proj_pyexcel.util import *


#==============================================================================
# experiment
#==============================================================================

#df=pd.read_csv('C:\\Users\\1580873\\Desktop\\Completed_Developments\\IntraGroup\\IntraGroup_LimitCat123_20180413.csv')
#
#filepath='C:\\Users\\1580873\\Desktop\\Completed_Developments\\test_pyexcel.xlsx'
#
#a=excel_editor(filepath, visibility=True)
#
#a.append_df_to_excel(df, sheetname='Sheet1', startrow=0, truncate_sheet=True)
#
#a.append_df_to_excel?
#
#import win32com.client
#win32 = win32com.client
#excel = win32com.client.gencache.EnsureDispatch('Excel.Application')
#wb = excel.Workbooks.Open('C:/Users/1580873/Desktop/Completed_Developments/IntraGroup/IntraGroup w cat3.xlsx')
#
#
#sheetnames = [wb.Worksheets(i).Name for i in range(1,wb.Worksheets.Count+1)]
#
#ws=wb.Worksheets('Summary')



#==============================================================================
# classes
#==============================================================================

class editor(object):

    __doc__ = """
    ==========================================
    INTERFACE for Python to interact with Excel.Application
    ==========================================
    - format excel ranges e.g. cell style, autofit columns width
    - conditional formatting on values
    - color scale formatting
    - copy and paste pandas.core.dataframe into excel sheets
    - create excel pivot tables with data from excel

    ==========================================
    SAMPLE YAML
    ==========================================
    # Display formatting
    loading:
        - AutoFitColumns
        
        - SetColumnsWidth:
            all_sheets: False
            sheetname: Sheet1
            columns: A:Z
            columnwidth: 15
            header: 1
    
        - AddSheet:
            sheetname: Sheet3
            before: Sheet2
            after: Sheet1
            
        - MoveSheet:
            sheetname: 
            before:
            after:
    
        - AutoFilter:
            sheetname: Sheet1
            cell_range: A1:Z1
        
        - FormatCells:
            all_sheets: False
            sheetname: Sheet1
            colnames: 
                - colA
                - colB
            numberformat: #,##,,
            header: 1
            
        - FormatConditionalGreaterThan:
            sheetname: Sheet1
            cell_range: B2:E10
            value: 100
            to_right: False
            to_bottom: False
            
        - FormatConditionalBetween:
            sheetname: Sheet1
            cell_range: B2:E10
            minimum: -100
            maximum: 100
            to_right: False
            to_bottom: False
            
        - FormatConditionalScale:
            sheetname: Sheet1
            cell_range: A1:Z10
            to_right: False
            to_bottom: False        
            color_scale: 3
            
        - NameRange:
            sheetname: Sheet1
            cell_range: A1:A10
            name: myNamedRangeForReferenceByFormulas
        
        - CreatePivotTables:
            PivotSourceRange: NamedRangeTable or "Sheet1!A1:Z10"
            PivotTablename: PivotTable1
            TargetSheet: Sheet2
            PivotFields:
                Filters:
                    ColA:
                        - category1
                        - category2
                    ColB: category3
                Columns:
                    - Level1 Less Granular
                    - Level2 More Granular
                Rows:
                    - Level1 Less Granular
                    - Level2 More Granular
                Values:
                    ColumnName: Outstanding
                    Formula: xlSum
                    PivotColumnName: Sum of Outstanding
                    NumberFormat: #,##,,
                                       
        - PasteFrame:
            sheetname: Sheet1
            frame: NameOfPandasLikeFrame
            cell_range: A1
            
        - AppendFrameToExcel:
            sheetname: Sheet1
            frame: NameOfPandasLikeFrame
            startrow: 1 or row to append dataframe
            truncate_sheet: False
        
    """
    
    @timeit
    def __init__(self, filepath, visibility=False):
        # init 1
        self._excel = win32com.client.gencache.EnsureDispatch('Excel.Application')
        self._excel.Visible = visibility
        print("Initialise win32com.Excel.App")
        self._wb = self._excel.Workbooks.Open(filepath)

        # init 2
        print("Initialise xlwings")
        self._wb_xw = xw.Book(filepath)
        
        self.filepath = filepath
        self.sheetcount = self._wb.Worksheets.Count
        self.sheetnames = [self._wb.Worksheets(i).Name for i in range(1,self.sheetcount+1)]
        self.colormap = {'yellow':65535,
                         'red':255,
                         'green':5287936,
                         'orange':49407
                         }
        
        self.tweak(on=True)
        
    @timeit
    def __del__(self):
        print("Running pyexcel.editor.__del__")
        self.close()
        pass

    def tweak(self, on):
        """ stop formula and screen uodating and no prompt """
        if on:
            self._excel.ScreenUpdating = False
            self._excel.Calculation = -4135 # manual
        else:
            self._excel.ScreenUpdating = True
            self._excel.Calculation = -4105 # automatic
            
    @timeit
    def close(self):
        ''' Closes win32com also closes xlwings opener ''' 
        print("pyexcel closing excel workbook...")
        self.tweak(on=False)
        
        try:
            self._wb.Save()
            self._wb.Close()
            if self._excel.Visible == False: 
                self._excel.Visible = True
            #self._excel.Application.Quit()
        except:
            print('No excel file to close!')

    #==============================================================================
    #     
    #==============================================================================

    def find_column(self, sheetname, keyword, header=1):
        ''' Find column letter in excel by searching row = header = 1 
            for keyword as column name
            ws.Rows("1:1").Find(What=keyword).Column'''
        idx_columns = [ (ind, obj) for ind, obj in 
                       enumerate(list(sheetname.Rows( str(header)+':'+str(header)
                       ).Value[0])) if obj is not None]
        for idx, colname in idx_columns:
            if colname == keyword:
                return colnum_to_letter(idx+1)

    def split_letter_row(self, ws, cell="A1"):
        ''' cell "A1" returns ['A','1'] '''
        return ws.Range(cell).Address.split("$")[1:]
    
    def last_column(self, ws, top_left="A1"):
        ''' returns last column letter '''
        return ws.Range(top_left).End(win32c.xlToRight).Address.split("$")[1]

    def last_row(self, ws, top_left="A1"):
        ''' returns last row number '''
        return ws.Range(top_left).End(win32c.xlDown).Address.split("$")[2]

    def auto_cell_range(self, ws, cell_range, 
                        to_right=False, to_bottom=False):
        ''' Objective:  returns cell range after performing xlToRight or xlDown
            Example:    A1 --> A1:Z10
        '''
        if to_right and to_bottom:
            last_letter = self.last_column(ws, top_left=cell_range)
            last_row = self.last_row(ws, top_left=cell_range)
            return cell_range + ":" + last_letter + last_row
        elif to_right: 
            last_letter = self.last_column(ws, top_left=cell_range)
            return cell_range + ":" + last_letter + self.split_letter_row(ws,cell_range)[1]
        elif to_bottom: 
            last_row = self.last_row(ws, top_left=cell_range)
            return cell_range + ":" + self.split_letter_row(ws,cell_range)[0] + last_row
        else:
            print("Invalid call given to conditional formatting cell range")
            return

    #==============================================================================
    #     
    #==============================================================================

    def ScanHeaders(self, sheetname, header=1):
        """ 
        Objective:  Scan sheet header row for cells with values 
        Example:    Find header column names
        @sheetname: sheet number or sheet name
        returns:    [('A', 'Outstanding'), ('B', 'Source'), ('C', 'Reporting Date')
        """
        ws = self._wb.Worksheets(sheetname)
        letter_colname = [(colnum_to_letter(idx+1),x) for idx,x in 
                          enumerate(list(ws.Rows( str(header)+':'+str(header) ).Value[0]))
                          if x is not None]
        print(letter_colname)
        return letter_colname
    
    def SortHeader(self, sheetname, groupby, 
                   header=1, index=True):
        """ 
        Objective: Sort values in column by ASC / DESC order
        @sheetname: str or int
        @groupby: list of keywords to sort OR can be exact column header names
        """        
        ws = self._wb.Worksheets(sheetname)
        
        header_range = self.ScanHeaders(sheetname, header)
        # skip first header colname
        if index: 
            _index = header_range[0]
            header_range = header_range[1:]
        
        new_header_order = []
        for group in groupby:
            for header in header_range:
                # column names in lower. SortHeader in Upper. 
                if group.lower() in str(header[1]).lower():
                    new_header_order.append(header)
        
        # Add new sheet, rename old sheet, 
        # copy data from old to new sheet, remove old sheet
        oldsheetname = sheetname + "_1"
        self.RenameSheet(newname=oldsheetname, sheetname=sheetname)
        self.AddSheet(sheetname = sheetname, before = oldsheetname)
        
        ws = self._wb.Sheets(oldsheetname)
        new_ws = self._wb.Sheets(sheetname)

        if index: 
            letter = _index[0]
            ws.Activate()
            ws.Columns(letter+":"+letter).Select()
            self._excel.Selection.Cut()
            new_ws.Activate()
            new_ws.Columns(letter).Select()
            new_ws.Paste()
            #new_ws.Columns(letter).Insert(Shift=win32c.xlToLeft)

        if index: 
            new_column_number = excel_column_number(letter)
            new_column_number += 1
        else:
            new_column_number = excel_column_number(new_header_order[0][0])
        
        print(new_header_order)
        for col in new_header_order:
            letter = col[0]
            ws.Activate()
            ws.Columns(letter).Select()
            self._excel.Selection.Cut()
            new_ws.Activate()
            new_ws.Columns(new_column_number).Select()
            new_ws.Paste()
            new_column_number += 1
            #new_ws.Columns(new_column_number).Insert(Shift=win32c.xlToRight)
            
        self.DeleteSheet(oldsheetname)
        pass
    
    def SortColumn(self, sheetname, column, header=1,
                   order='ASC'):
        """ 
        Objective: Sort values in column by ASC / DESC order
        @sheetname: str or int
        @column: "A" or column header name
        @order: 
        """
        if order == 'ASC':
            order = win32c.xlAscending
        else: 
            order = win32c.xlDescending

        ws = self._wb.Worksheets(sheetname)
        
        header_range = self.ScanHeaders(sheetname, header)
        header_range = [x[0] for x in header_range]
        headerRange = header_range[0] + ":" + header_range[-1]
        
        #Key2,Key3,...Composite sorting in keys order
        ws.Columns(headerRange).Sort(Key1=ws.Range(column+header), 
                                   Order1=order, 
                                   Orientation=win32c.xlSortColumns)
        pass
    
    def UpdateSheets(self):
        ''' Update sheet count and names '''
        self.sheetcount = self._wb.Worksheets.Count
        self.sheetnames = [self._wb.Worksheets(i).Name for i in range(1,self.sheetcount+1)]
        pass
        
    def DeleteSheet(self, sheetname='Sheet1'):
        '''
        @sheetname: str sheetname or int sheet number
        '''
        # remove prompt with .DisplayAlerts = False
        self._excel.DisplayAlerts = False
        self._wb.Sheets(sheetname).Delete()
        self.UpdateSheets()
        self._excel.DisplayAlerts = True
        pass
    
    def RenameSheet(self, newname, sheetname='Sheet1'):
        '''
        @sheetname: str sheetname or int sheet number
        @newname: new sheetname str
        '''
        self._wb.Sheets(sheetname).Name = newname        
        self.UpdateSheets()
        pass
    
    def AddSheet(self, sheetname='Sheet1', before=None, after=None):
        '''
        @sheetname: str
        @before: before which sheet?
        @after: after which sheet?
        '''        
        if sheetname in self.sheetnames: 
            print("Sheet " + sheetname + " already exists!")
            return
        # auto append to last sheet if after,before is None
        if not after is None:
            after = self._wb.Sheets(after)
        if not before is None:
            before = self._wb.Sheets(before)
        if before is None and after is None:
            after = self._wb.Sheets(self._wb.Sheets.Count)
        newsht = self._wb.Sheets.Add(Before = before, After = after)
        newsht.Name = sheetname
        self.UpdateSheets()
        pass
    
    def NameRange(self, sheetname, cell_range, name,
                  to_right=True, to_bottom=True):
        '''
        @sheetname: number or name
        @cell_range: "$A1:$C10" or "A:D"
        @name: name of cells range in excel
        '''
        ws = self._wb.Worksheets(sheetname)
        if cell_range.find(':') == -1:
            cell_range = self.auto_cell_range(ws, cell_range, to_right, to_bottom)
            print("cell_range in NameRange automatically become " + cell_range)
        
        # RefersTo is relative
        #self._wb.Sheets(sheetname).Range(cell_range.split(":")[0]).Select()
        #self._wb.Names.Add(Name=name, RefersTo="="+sheetname+"!"+cell_range)
        rng = self._wb.Sheets(sheetname).Range(cell_range)
        self._wb.Names.Add(Name=name, RefersToR1C1 = rng)
        pass

    def AutoFilter(self, sheetname, cell_range):
        '''
        @sheetname: sheetname or sheet number
        @cell_range: columns where dropdown selection will be. 
                        Last hierarchy if nested columns.
                        "A2:N2"
        '''
        self._wb.Worksheets(sheetname).Range(cell_range).AutoFilter(1)
        pass

    def MoveSheet(self, sheetname, before=None, after=None):
        '''
        @sheetname: sheetname or sheet number
        @before: sheetname or sheet number
        @after: sheetname or sheet number
        '''
        if before is not None and after is not None: after = None
        if before is not None and after is None:
            self._wb.Worksheets("CAT1 Details").Move(Before=self._wb.Worksheets(before))
        elif before is None and after is not None:
            self._wb.Worksheets("CAT1 Details").Move(After=self._wb.Worksheets(after))
        else:
            print("Need to specify either sheet before or after")
        self.UpdateSheets()
        pass
    
    def GetPivotTables(self):
        """ returns list of pivot table names """
        pivot_names = []
        for sheetname in self.sheetnames:
            ws = self._wb.Worksheets(sheetname)
            pivot_tables=ws.PivotTables()
            for p in pivot_tables:
                pivot_names.append(str(p.Name))
        print("Pivot table names: " +  str(pivot_names))
        return pivot_names
    
    def CreatePivotTables(self, PivotSourceRange, PivotTableName, 
                          TargetSheet, PivotFields, 
                          TargetCell = [1,1]):
        """        
        @PivotSourceRange: named excel range or Range("Sheet1!A1:C4") etc...
        @PivotTableName = 'by_productdesc'
        @TargetSheet: target sheet number or sheetname where table goes to 
        @target: top left cell of pivot table target range [row, column]
        @PivotFields: dictionary type            
        {
            Filters: {
                    colname1 : which category in colname1? " list or str
                    }
            Columns: [colname of less granular, followed by colname of more granular, ...]
            Rows: [colname of less granular, followed by colname of more granular, ...]
            Values: {
                    ColumnName: 'Outstanding'
                    Formula: xlSum / xlCount / xlAverage / xlMax / xlMin / xlProduct
                    PivotColumnName: 'Sum of Outstanding'
                    NumberFormat: '#,##,,'
                    }
        }
        
        ########### Parse into Excel VBA ###########
        # filter        
        PivotTable.PivotFields("legalname").Orientation = win32c.xlPageField        
        PivotTable.PivotFields("legalname").CurrentPage = "STANDARD CHARTERED BANK"
 
        # column
        PivotTable.PivotFields('product').Orientation = win32c.xlColumnField
        
        # row
        PivotTable.PivotFields('productdesc').Orientation = win32c.xlRowField
        
        # value
        DataField = PivotTable.AddDataField(PivotTable.PivotFields('outstanding'),
                                            "Sum of CAT1 Outstanding",win32c.xlSum)
        DataField.NumberFormat = '#,##0,,'
        """
        try: 
            ws = self._wb.Worksheets(TargetSheet)
        except:
            print("Target Sheet["  + TargetSheet + "] not found!")
            return
        anchor  = ws.Cells(TargetCell[0], TargetCell[1])
        PivotTargetRange = ws.Range(anchor, anchor)
        # https://msdn.microsoft.com/en-us/vba/excel-vba/articles/pivotcache-object-excel
        PivotCache = self._wb.PivotCaches().Create(SourceType=win32c.xlDatabase,
                                         SourceData=PivotSourceRange, 
                                         Version=6)
        #auto refresh pivot table when wb reopen
        PivotCache.RefreshOnFileOpen = True
        PivotCache.MissingItemsLimit = win32c.xlMissingItemsDefault


        #check for pivot table names duplicate
        pivot_tables_names = self.GetPivotTables()
        counter_avoid_duplicate = 1
        while PivotTableName in pivot_tables_names:
            PivotTableName = PivotTableName + "_" + str(counter_avoid_duplicate)
            counter_avoid_duplicate += 1
        
        # Create Pivot Table templates
        PivotTable = PivotCache.CreatePivotTable(TableDestination=PivotTargetRange, 
                                         TableName=PivotTableName, DefaultVersion=6)
        
        #set table fields
        if isinstance(PivotFields, dict):

            # column
            if 'Columns' in list(PivotFields.keys()):            
                Columns = PivotFields['Columns']
                if isinstance(Columns,str):
                    PivotTable.PivotFields(Columns).Orientation = win32c.xlColumnField
                elif isinstance(Columns,list):
                    pos_count = 1
                    for header in Columns:
                        PivotTable.PivotFields(header).Orientation = win32c.xlColumnField
                        PivotTable.PivotFields(header).Position = pos_count
                        pos_count += 1
                else:
                    print("values in PivotFields['Columns'] can only be str or list type")
            else:
                print("No Columns in Excel PivotTable " + PivotTableName + " Creation")
                
            # row
            if 'Rows' in list(PivotFields.keys()):            
                Rows = PivotFields['Rows']
                if isinstance(Rows,str):
                    PivotTable.PivotFields(Rows).Orientation = win32c.xlRowField
                elif isinstance(Rows,list):
                    pos_count = 1
                    for index in Rows:
                        PivotTable.PivotFields(index).Orientation = win32c.xlRowField
                        PivotTable.PivotFields(index).Position = pos_count
                        pos_count += 1
                else:
                    print("values in PivotFields['Rows'] can only be str or list type")
            else:
                print("No Rows in Excel PivotTable " + PivotTableName + " Creation")

            # value
            if 'Values' in list(PivotFields.keys()):
                Values = PivotFields['Values']
                ColumnName = Values['ColumnName']
                Formula = eval("win32c." + Values['Formula'])
                PivotColumnName = Values['PivotColumnName']
                DataField = PivotTable.AddDataField(PivotTable.PivotFields(ColumnName),
                                                    PivotColumnName, Formula)
                if 'NumberFormat' in list(Values.keys()):
                    if not Values['NumberFormat'] is None:
                        DataField.NumberFormat = Values['NumberFormat']
            else:
                print("No Values in Excel PivotTable " + PivotTableName + " Creation")

            # filter
            if 'Filters' in list(PivotFields.keys()):
                Filters = PivotFields['Filters']
                for colname, categories in Filters.items():
                    pos_count = 1
                    print("Filtering " + colname + " for: " + str(categories))
                    PivotTable.PivotFields(colname).Orientation = win32c.xlPageField
                    PivotTable.PivotFields(colname).Position = pos_count
    
                    PivotTable.PivotFields(colname).CurrentPage = "(All)"
                    PivotTable.PivotFields(colname).EnableMultiplePageItems = True
                    all_categories = [str(x) for x in PivotTable.PivotFields(colname).PivotItems()]
                    for cat in all_categories:
                        if cat in categories:
                            PivotTable.PivotFields(colname).PivotItems(cat).Visible = True
                        else:
                            PivotTable.PivotFields(colname).PivotItems(cat).Visible = False
                    pos_count += 1
            else:
                print("No Filters in Excel PivotTable " + PivotTableName + " Creation")
        else:
            print("Pivot Fields input to CreatePivotTables needs to be in dictionary\n\
                  keys: Filters, Columns, Rows, Values")
       

    doc_formatconditional = '''
        @sheetname: sheet number or sheet name
        @cell_range: "A2:F20"
        @value: highlight cells whose values more than this 'value'
        @to_right: cell_range will be "A2" and it will translate to "A2:<last_letter>2"
        @to_bottom: cell_range will be "A2" and it will translate to "A2:A<last_row>"
        @color: color to highlight cells with
        '''

    def _formatConditional(self, sheetname, cell_range, value, operator,
                          to_right=False, to_bottom=False, 
                          Formula1=None, Formula2=None, color = 49407,
                          autofind=False, header=1):
        '''
        @operator: win32.constants.xlGreater / xlLess / xlCellValue
        @Formula1 is value for comparison in excel. Need Formula2 for xlBetween
        '''
        ws = self._wb.Worksheets(sheetname)
        if autofind:
            # is header column name
            header_range = self.ScanHeaders(sheetname, header)
            for letter, colname in header_range:
                if cell_range == colname:
                    cell_range = letter + str(header+1)
                    break
            else:
                print("AutoFind Column name not found")

        cell_range = self.auto_cell_range(ws, cell_range, to_right, to_bottom)
        
        if not Formula1 is None: Formula1 = "=" + str(Formula1)
        if not Formula2 is None: Formula2 = "=" + str(Formula2)            
        ws.Range( cell_range ).FormatConditions.Add(Type=win32c.xlCellValue, 
                  Operator=win32c.xlGreater, Formula1=Formula1, Formula2=Formula2)
        last_condition = ws.Range( cell_range ).FormatConditions.Count
        ws.Range( cell_range )\
            .FormatConditions(last_condition)\
            .Interior.Color = self.colormap[color]

    @docstring(doc_formatconditional)
    def FormatConditionalGreaterThan(self, sheetname, cell_range, value, 
                                     to_right=False, to_bottom=True, color = 'green',
                                     autofind=True, header=1):
        self._formatConditional(sheetname, cell_range, value, 
                                operator = win32c.xlGreater, 
                                to_right=to_right, to_bottom=to_bottom, 
                                Formula1= value, 
                                color = color, 
                                autofind = autofind,
                                header=header)

    @docstring(doc_formatconditional)
    def FormatConditionalLessThan(self, sheetname, cell_range, value, 
                                  to_right=False, to_bottom=True, color = 'red',
                                  autofind=True, header=1):                                  
        self._formatConditional(sheetname, cell_range, value,  
                               operator = win32c.xlLess, 
                               to_right=to_right, to_bottom=to_bottom, 
                               Formula1= value, 
                               color = color, 
                               autofind = autofind,
                               header=header)
        
    @docstring(doc_formatconditional)
    def FormatConditionalBetween(self, sheetname, cell_range, minimum, maximum, 
                                 to_right=False, to_bottom=True, color = 'orange',
                                 autofind=True, header=1):
        self._formatConditional(sheetname, cell_range, value=None, 
                                operator = win32c.xlBetween,
                                to_right=to_right, to_bottom=to_bottom, 
                                Formula1= minimum, Formula2= maximum, 
                                color = color, 
                                autofind = autofind,
                                header=header)
    
    def FormatConditionalScale(self, sheetname, cell_range,
                                to_right=False, to_bottom=True,
                                color_scale=3, 
                                autofind=True, header=1):
        """
        @sheetname: sheet number or sheet name
        @cell_range: "A2:F20"
        @to_right: cell_range will be "A2" and it will translate to "A2:<last_letter>2"
        @to_bottom: cell_range will be "A2" and it will translate to "A2:A<last_row>"
        @color_scale: color to highlight cells with
        """
        ws = self._wb.Worksheets(sheetname)
        if autofind:
            # is header column name
            header_range = self.ScanHeaders(sheetname, header)
            for letter, colname in header_range:
                if cell_range == colname:
                    cell_range = letter + str(header+1)
                    break
            else:
                print("AutoFind Column name not found")

        cell_range = self.auto_cell_range(ws, cell_range, to_right, to_bottom)
        ws.Range( cell_range ).FormatConditions.AddColorScale(ColorScaleType=color_scale)
           
    def SetColumnsWidth(self, columns, sheetname=None,
                      columnwidth = 15, header=1,
                      all_sheets=False):
        """ 
        Objective:  Set excel sheet columns width 
        @sheetname: sheet number or sheet name
        @columns:   example "B:E" or "B" and it auto finds the last column in sheet
        @columnwidth: Excel's Width
        @header: 1 by default. The first row in excel sheet.
        """
        if all_sheets:           
            for i in range(1,self.sheetcount+1):
                return self.SetColumnsWidth(columns=columns, sheetname=i,
                                            columnwidth = columnwidth, header=header,
                                            all_sheets=False)

        else:
            print("Setting sheet["+ str(sheetname) + "] Columns Width to " + str(columnwidth) )
            ws = self._wb.Worksheets(sheetname)
            # wraps header
            ws.Rows(str(header) + ":" + str(header)).WrapText = True
            if columns.find(":") == -1:
                # auto finds last column
                ws.Columns(columns+":" + \
                           self.last_column(ws, top_left = columns+header)).ColumnWidth = columnwidth
            else:
                ws.Columns(columns).ColumnWidth = columnwidth
                    
    def AutoFitColumns(self):
        """ Autofit columns width for all excel sheets """
        for i in range(1,self.sheetcount+1):
            ws = self._wb.Worksheets(i)
            ws.Columns.AutoFit()
        
    def FormatCells(self, colnames, numberformat, sheetname = None,
                    autofind=True, header=1, all_sheets=False):
        """
        @colnames: list of column names or str A:Z
        @numberformat: #,##,,.0 %0.0
        @header: row number in excel sheet
        @autofind: True then finds columnname from header row
        @all_sheets: Apply same parameters for all sheets
        """
        if all_sheets:           
            for i in range(1,self.sheetcount+1):
                print(colnames)
                print(locals())
                self.FormatCells(colnames=colnames, 
                                 numberformat=numberformat,
                                 sheetname = i, autofind=autofind, 
                                 header=header, all_sheets=False)
            
        else:
            ws = self._wb.Worksheets(sheetname)
            
            print(locals())
            
            if autofind:
                if isinstance(colnames,list):
                    for names in colnames:
                        try:
                            # Default exact match
                            where = ws.Rows(str(header)+':'+str(header)).Find(What=names).Column
                            let=list(string.ascii_uppercase)[where-1]
                            print(let+':'+let)
                            ws.Columns(let+':'+let).NumberFormat  = numberformat
                        except:
                            print('No such column ' + names + " in sheet[" + sheetname + "]")
                elif isinstance(colnames,str):
                    try:
                        # Default exact match
                        where = ws.Rows(str(header)+':'+str(header)).Find(What=colnames).Column
                        let=list(string.ascii_uppercase)[where-1]
                        print(let+':'+let)
                        ws.Columns(let+':'+let).NumberFormat  = numberformat
                    except:
                        print('No such column ' + names + " in sheet[" + sheetname + "]")
                else:
                    print("Invalid colnames dtype")
            else:
                print(colnames)
                try:
                    if colnames.find(":") == -1: colnames = colnames + ":" + colnames
                    ws.Columns(colnames).NumberFormat  = numberformat
                except:
                    print('No such column ' + names + " in sheet[" + sheetname + "]")


    def PasteFrame(self, sheetname, frame, cell_range='A1'):
        '''
        @sheetname: sheetname or sheet number
        @frame: Pandas.core.DataFrame. Type can be str, int
        @cell_range: top left cell value for pasting dataframe
        '''
        sht = self._wb_xw.sheets[sheetname]
        sht.range(cell_range).value = frame
        pass
       
    def AppendFrameToExcel(self, frame, sheetname='Sheet1', startrow=None,
                           truncate_sheet=False, 
                           **to_excel_kwargs):
        """
        Append a DataFrame [frame] to existing Excel file [filename]
        into [sheetname] Sheet.
        If [filename] doesn't exist, then this function will create it.
    
        Parameters:
          filename : File path or existing ExcelWriter
                     (Example: '/path/to/file.xlsx')
          frame : dataframe to save to workbook
          sheetname : Name of sheet which will contain DataFrame.
                       (default: 'Sheet1')
          startrow : upper left cell row to dump data frame.
                     Per default (startrow=None) calculate the last row
                     in the existing DF and write to the next row...
                     Starts from 1th row. 
          truncate_sheet : truncate (remove and recreate) [sheetname]
                           before writing DataFrame to Excel file
          to_excel_kwargs : arguments which will be passed to `DataFrame.to_excel()`
                            [can be dictionary]
                            
                            
          Parameters
            ----------
            excel_writer : string or ExcelWriter object
                File path or existing ExcelWriter
            sheetname : string, default 'Sheet1'
                Name of sheet which will contain DataFrame
            na_rep : string, default ''
                Missing data representation
            float_format : string, default None
                Format string for floating point numbers
            columns : sequence, optional
                Columns to write
            header : boolean or list of string, default True
                Write out column names. If a list of string is given it is
                assumed to be aliases for the column names
            index : boolean, default True
                Write row names (index)
            index_label : string or sequence, default None
                Column label for index column(s) if desired. If None is given, and
                `header` and `index` are True, then the index names are used. A
                sequence should be given if the DataFrame uses MultiIndex.
            startrow :
                upper left cell row to dump data frame
            startcol :
                upper left cell column to dump data frame
            engine : string, default None
                write engine to use - you can also set this via the options
                ``io.excel.xlsx.writer``, ``io.excel.xls.writer``, and
                ``io.excel.xlsm.writer``.
            merge_cells : boolean, default True
                Write MultiIndex and Hierarchical Rows as merged cells.
            encoding: string, default None
                encoding of the resulting excel file. Only necessary for xlwt,
                other writers support unicode natively.
            inf_rep : string, default 'inf'
                Representation for infinity (there is no native representation for
                infinity in Excel)
            freeze_panes : tuple of integer (length 2), default None
                Specifies the one-based bottommost row and rightmost column that
                is to be frozen
            
                .. versionadded:: 0.20.0
    
        Returns: None
        """
        
        # ignore [engine] parameter if it was passed
        if 'engine' in to_excel_kwargs:
            to_excel_kwargs.pop('engine')
    
        writer = pd.ExcelWriter(self.filepath, engine='openpyxl')

        
        try:
            # try to open an existing workbook
            writer.book = load_workbook(self.filepath)
    
            # get the last row in the existing Excel sheet
            # if it was not specified explicitly
            if startrow is None and sheetname in writer.book.sheetnames:
                startrow = writer.book[sheetname].max_row
                print("Startrow auto detect is " + str(startrow))
            if not startrow is None:
                startrow -= 1 # start from 1th row, not 0th row
    
            # truncate sheet
            if truncate_sheet and sheetname in writer.book.sheetnames:
                # index of [sheetname] sheet
                idx = writer.book.sheetnames.index(sheetname)
                # remove [sheetname]
                writer.book.remove(writer.book.worksheets[idx])
                # create an empty sheet [sheetname] using old index
                writer.book.create_sheet(sheetname, idx)
    
            # copy existing sheets
            writer.sheets = {ws.title:ws for ws in writer.book.worksheets}
        except FileNotFoundError:
            # file does not exist yet, we will create it
            pass
    
        if startrow is None:
            startrow = 0
    
        # write out the new sheet
        frame.to_excel(writer, sheetname, startrow=startrow, **to_excel_kwargs)
        
        # save the workbook
        try:
            writer.save()
        except PermissionError:
            print("Closing opened workbook for appending")            
            self.close()
            writer.save()
            print("Reinitialise")
            self.__init__(self.filepath, self._excel.Visible)
            print("Reopening opened workbook for appending")

    #==============================================================================
    #     
    #==============================================================================

    def FreezePane(self, sheetname, cell):
        '''
        @sheetname: sheetname or sheet number
        @cell: top left corner of frozen panes
        '''
        self._wb.Worksheets(sheetname).Range(column_range).AutoFilter(1)
        if self._excel.Visible == False: 
            self._excel.Visible = True
            revert = True
        else: 
            revert = False

        self._wb.Worksheets(sheetname).Range(cell).Select()
        self._excel.ActiveWindow.FreezePanes = True
        if revert: self._excel.Visible = False
        pass

    def FreezeColumn(self):
        self.freezepane(sheetname, cell='B1')

    def FreezeRow(self):
        self.freezepane(sheetname, cell='A2')


    def iterator(self, method):
        """
        Objective:  iterate a method on all sheets in excel with 
                    the same arguments. Uses functools.partial to keep
                    sheetname blank. 
        @method: functools.partial method in "this" pyexcel.editor class
        """
        print("Iterating")
        for i in range(1,self.sheetcount+1):
            method(sheetname=i)
#==============================================================================
# decorators
#==============================================================================

import time

def timeit(method):
    def timed(*args, **kw):
        ts = time.time()
        result = method(*args, **kw)
        te = time.time()
        if 'log_time' in kw:
            name = kw.get('log_name', method.__name__.upper())
            kw['log_time'][name] = int((te - ts) * 1000)
        else:
            print( '%r  %2.2f ms' %  (method.__name__, (te - ts) * 1000))
        return result
    return timed

def docstring(docstr, sep="\n"):
    """
    Decorator: Append to a function's docstring.
    """
    def _decorator(func):
        if func.__doc__ == None:
            func.__doc__ = docstr
        else:
            func.__doc__ = sep.join([func.__doc__, docstr])
        return func
    return _decorator
class xlwings_editor(object):
    
    def __init__(self, filepath):
        self._wb = xw.Book(filepath)
    
    def __del__(self):
        self.close()
    
    def paste_frame(self, ws, df, topleft='A1'):
        '''
        @ws: sheetname or sheet number
        @topleft: top left cell value for pasting dataframe
        '''
        sht = self._wb.sheets[ws]
        sht.range(topleft).value = df        
        pass
    
    def close(self):
        self._wb.save()
        self._wb.close()
        pass

    def test(self,a):
        print(a)
        pass


class win32com_editor(object):
    
    def __init__(self, filepath):
        self.win32 = win32com.client
        self._excel = win32com.client.gencache.EnsureDispatch('Excel.Application')
        self._excel.Visible = True
        self._wb = self._excel.Workbooks.Open(filepath)
        
    
    def __del__(self):
        self.close()
    
    def test(self,a):
        print(a)
        pass

#==============================================================================
# util
#==============================================================================

def excel_column_name(n):
    """Number to Excel-style column name, e.g., 1 = A, 26 = Z, 27 = AA, 703 = AAA."""
    name = ''
    while n > 0:
        n, r = divmod (n - 1, 26)
        name = chr(r + ord('A')) + name
    return name

def excel_column_number(name):
    """Excel-style column name to number, e.g., A = 1, Z = 26, AA = 27, AAA = 703."""
    n = 0
    for c in name:
        n = n * 26 + 1 + ord(c) - ord('A')
    return n

#def test (name, number, colnumbers):
#    letters = []
#    for n in colnumbers:
#        a = name(n)
#        n2 = number(a)
#        a2 = name(n2)
#        letters.append(a)
#        #print ("%10d  %-9s  %s" % (n, a, "ok" if a == a2 and n == n2 else "error %d %s" % (n2, a2)))
#    return letters[1:]
    
def colnum_to_letter(colnumbers):
    """ exchange excel column number to column letter """
    if isinstance(colnumbers, int):
        return excel_column_name(colnumbers)
    elif isinstance(colnumbers, list):
        letters = []
        for n in colnumbers:
            letters.append(excel_column_name(n))
        return letters[1:]
    else:
        print("Unsupported colnumbers format")
        
#colnumbers = [0, 1, 2, 3, 4, 24, 25, 26, 27, 702, 703, 704]
#test(excel_column_name, excel_column_number, colnumbers)



